---
title: "AI-naloga-unfinished"
output:
  pdf_document: default
  html_notebook: default
---

## Obdelava podatkov in dodajanje atributov

Na začetku uvozimo podatke z gumbom v RStudio imenovanem "Import Dataset" in sicer izberemo opcijo "From Text(base)". Nato ustvarimo novo delovno spremenljivko "data", da ostane prvotna spremenljivka nespremenjena. 


```{r Uvoz podatkov}
dataSem1 <- read.csv("../dataSem1.txt", stringsAsFactors=TRUE)

data <- dataSem1
data$regija <- as.factor(data$regija)
data$namembnost <- as.factor(data$namembnost)
data$norm_poraba <- as.factor(data$norm_poraba)

head(data)
```
Atribute "regija", "namembnost" in "norm_poraba" faktoriziramo, da programski jezik razbere zalogo vrednosti. V tabeli zgoraj je prikazanih prvih nekaj vrstic. 

```{r Določitev tipa atributa "datum"}
library(tictoc)
data$datum <- as.Date(data$datum)
head(data)

```
Lastnost atributa "datum" nastavimo na <date>.

```{r Dodan atribut mesec}
library(lubridate)

newData <- week(data$datum)

data$teden <- newData

newNewData <- month(data$datum)
data$mesec <- newNewData

head(data)
```
V tem delu dodamo nova atributa "teden" in "mesec" za lažje nadaljno delo. Za pomoč uporabimo knjižnico "lubridate".

```{r Dodan atribut vikend}
library(chron)

x <- is.weekend(data$datum)
data$vikend <- x
```
Zgornja koda prikazuje kako dodamo atribut "vikend", ki ima vrednost TRUE, če je dan sobota ali nedelja, oziroma FALSE, če je delovni dan. Pomagamo si s knjižnico "chron".


```{r Dodan atribut UNIX}
data$UNIX <- as.numeric(as.POSIXct(paste(data$datum, data$ura, sep=" ")))
```
Ustvarimo splošen atribut za čas, ki nam omogoča lažje sortiranje.




```{r Ustvarjen kronološko sortiran seznam}
a <- order(data$stavba, data$ura, data$UNIX)
sortedDF <- data[a,]
sortedDF
```
Dataframe sortiramo po številki stavbe, uri meritve in UNIX času.


```{r Izračun podatkov meritve prejšnjega dne}
tic()
vect = vector()
starTemp = 0
uraMeritve = 0
for (row in 1:nrow(sortedDF))
{
  if(uraMeritve == sortedDF[row, "ura"]) {
    vect <- c(vect, starTemp)
  }
  else {
    uraMeritve = sortedDF[row, "ura"]
    vect <- c(vect, sortedDF[row, "temp_zraka"])
  }
  starTemp = sortedDF[row, "temp_zraka"]
}
toc()
```

```{r Dodan atribut temperatura prejšnjega dne}
sortedDF$norm_poraba <- factor(sortedDF$norm_poraba, levels=c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA"))
sortedDF$ura <- factor(sortedDF$ura)
sortedDF$oblacnost <- factor(sortedDF$oblacnost)

sortedDF$prev_temp <- vect
head(sortedDF)
```
S kodo zgornjih dveh odlomkov vsaki meritvi v sortirani matriki poiščemo meritev temperature prejšnjega dne in ji le to dopišemo v poseben stolpec z atributi.



```{r Izračun temperature prejšnjih 7 dni}
tic()
vect = vector()
starTemp = 0
uraMeritve = 0
substract = 0
beginning = 0
stevec = 0
for (row in 1:nrow(sortedDF))
{
  if(beginning < row-7)
    stevec = row-7
  else
    stevec = beginning
  if(uraMeritve == sortedDF[row, "ura"]) {
    starTemp = 0
    
    for (i in stevec:(row-1))
      starTemp = starTemp + sortedDF[i, "temp_zraka"]
    avgTemp = starTemp / (row - stevec)
    vect <- c(vect, avgTemp)
  }
  else {
    beginning = row
    uraMeritve = sortedDF[row, "ura"]
    vect <- c(vect, sortedDF[row, "temp_zraka"])
  }
  starTemp = sortedDF[row, "temp_zraka"]
}
toc()
```

```{r Dodan atribut temperatura prejšnjih 7 dni}
sortedDF$temp_teden <- vect
head(sortedDF)
```
Z zanko se sprehodimo po vsaki meritvi v matriki in izračunamo povprečje največ zadnjih 7 meritev za isto stavbo ob isti uri. Povprečno temperaturo zapišemo v stolpec z imenom "temp_teden".

## Analiza podatkov

```{r}
library("plot3D")
library(dplyr)
usefull_data <- filter(sortedDF, smer_vetra > 0)
scatter2D(usefull_data$smer_vetra, usefull_data$temp_zraka, clab = c("Temperatura zraka", "smer_vetra, hitrost_vetra"))
scatter3D(usefull_data$smer_vetra, usefull_data$hitrost_vetra, usefull_data$temp_zraka, phi = 10, theta = 20, bty ="g", ticktype = "detailed")
```



## Večinski razred

```{r Graf razporeditve po normirani porabi}
plot(sortedDF$norm_poraba, main = "Porazdelitev primerov glede na normirano stopnjo porabe")
```

```{r Številski opis normirane porabe}
summary(sortedDF$norm_poraba)
```
Večinski parameter je vrednost "SREDNJA", ki predstavlja 76.435 vrednosti od 206.785, kar je 0,3696 od celotne zaloge elementov.

### Analiza večinskega modela

```{r Matrika dejanskih vrednosti nominirane temperature}
library(nnet)

observedMat <- list()
for (i in 1:11) {
  observedMat[[i]] <- class.ind(factor(filter(sortedDF, mesec == i+1)$norm_poraba, levels=c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")))
}
head(observedMat[[1]])
```
Za izluščenje le posameznega meseca se uporabi knjižnica "dplyr", kjer s pomočjo fukcije "filter" izluščimo le podatke določenega meseca.

```{r Barierjev test večinskih modelov}

cat("Večinski model\n")
for(i in 1:11){
  p0 <- table(filter(sortedDF, mesec <= i+1)$norm_poraba)/nrow(filter(sortedDF, mesec <= i+1))
  cat("Mesec =", i+1, " ->  ")
  p0Mat <- matrix(rep(p0, times=nrow(observedMat[[i]])), nrow = nrow(observedMat[[i]]), byrow = T)
  colnames(p0Mat) <- names(p0)
  bar <- sum((observedMat[[i]] - p0Mat) ^ 2) / nrow(p0Mat)
  cat(bar, "\n")
}

```


```{r Funkcija informacijske vsebine odgovora}
inf.score <- function(trainClass, testClass, predMat) {
  result <- 0
  priors <- table(trainClass) / length(trainClass)
  
  for (i in 1:nrow(predMat)) {
    p.prior <- priors[testClass[i]]
    p.posterior <- predMat[i, testClass[i]]
    
    if(p.posterior >= p.prior) {
      result <- result - log2(p.prior) + log2(p.posterior)
    }
    else
      result <- result + log2(1-p.prior) - log2(1-p.posterior)
  }
  
  result/nrow(predMat)
}
```


```{r Izračun informacijske vsebine trivialnega modela}
cat("Informacijska vsebina trivialnega modela\n")
for (i in 1:11) {
  p0 <- table(filter(sortedDF, mesec <= i+1)$norm_poraba)/nrow(filter(sortedDF, mesec <= i+1))
  cat("Mesec =", i+1, " ->  ")
  p0Mat <- matrix(rep(p0, times=nrow(filter(sortedDF, mesec == i+1))), nrow = nrow(filter(sortedDF, mesec == i+1)), byrow = T)
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, p0Mat), "\n")
}
```


## Odločitveno drevo

```{r Izračun odločitvenih dreves}
library(rpart)

dt_list <- list()
tic()
for(m in 1:11) {
  tempDF <- filter(sortedDF, mesec <= m)
  
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  dt_list[[m]] <- rpart(norm_poraba ~ ., data = tempDF, cp = 0)
  tab <- printcp(dt_list[[m]])
  row <- which.min(tab[,"xerror"])
  th <- mean(c(tab[row, "CP"], tab[row-1, "CP"]))
  dt_list[[m]] <- prune(dt_list[[m]], cp = th)
}

cat("\014")
toc()
rm(tab)
rm(row)
rm(th)
```
Zgoraj so narejena drevesa za vseh 11 mesecev razen decembra, ki se samo testira.



```{r Izris odločitvenih dreves}
library(rpart.plot)

#for(m in dt_list)
  #rpart.plot(m)
```



```{r Napoved odločitvenih dreves}
tic("Total")

predicted <- list()
for (i in 1:11) {
  tic(i)
  tempDF <- filter(sortedDF, mesec == i+1)
  predicted[[i]] <- predict(dt_list[[i]], tempDF, type = "class")
  toc()
}
toc()
```

### Analiza odločitvenega drevesa
```{r Pravilnost rezultatov odločitvenih dreves}
# Tabela zmot
cat("Pravilnost rezultatov \n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  q <- filter(sortedDF, mesec == i+1)$norm_poraba == predicted[[i]]
  cat(mean(q))
  #tab <- table(predicted[[i]],filter(sortedDF, mesec == i+1)$norm_poraba)
  cat(" +/-", sd(q)/sqrt(length(q)), "\n")
}
```


```{r Senzitivnost odločitvenih dreves}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predicted[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab["SREDNJA",]), "\n")
}
```



```{r Specifičnost odločitvenih dreves}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predicted[[i]])
  cat((sum(tab)-sum(tab["SREDNJA",])-sum(tab[,"SREDNJA"])+tab["SREDNJA","SREDNJA"])/(sum(tab)-sum(tab[,"SREDNJA"])), "\n")
}
```


```{r Preciznost odločitvenih dreves}
#cat("Preciznost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predicted[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab[,"SREDNJA"]), "\n")
}
```

```{r Izračun matrike napovedi odločitvenih dreves}
i = 1
predictedMat <- list()
for (dt in dt_list) {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedMat[[i]] <- predict(dt, tempDF, type = "prob")
  i = i + 1
}
col.order <- c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")
head(predictedMat[[1]][,col.order])
```



```{r Barierjev test odločitvenih dreves}
print("Barier's test", quote = F)
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  bar <- sum((observedMat[[i]] - predictedMat[[i]]) ^ 2) / nrow(predictedMat[[i]])
  cat(bar, "\n")
}
```



```{r Izračun informacijske vsebine odločitvenih dreves}
cat("Informacijska vsebina odgovora\n")
for (i in 1:11) {
  cat("Mesec =", i+1, " ->  ")
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, predictedMat[[i]]), "\n")
}
```


## Naivni Bayesov klasifikator

```{r Parallel libraries}
library(foreach)
library(doParallel)
numCores <- detectCores()
numCores
registerDoParallel(cores = numCores)
```


```{r Izračun modelov Naivni Bayes}
library(e1071)

nb_list <- list()
tic()
for(m in 1:11) {
  tempDF <- filter(sortedDF, mesec <= m)
  
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  nb_list[[m]] <- naiveBayes(norm_poraba ~ ., data = tempDF)
}
toc()
```


```{r Napoved po naivnem Bayesu paralelizirana}
tempDF <- list()
tic()
predictedBayes <- list()
predictedBayes <- foreach (i=1:11) %dopar% {
  tempDF[[i]] <- filter(sortedDF, mesec == i+1)
  predictedBayes[[i]] <- predict(nb_list[[i]], tempDF[[i]], type = "class")
}
cat("\014")
toc()
```


### Analiza Naivnega Bayesovega klasifikatorja

```{r Pravilnost rezultatov Naivnega Bayesa}
# Tabela zmot
cat("Pravilnost rezultatov \n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  q <- filter(sortedDF, mesec == i+1)$norm_poraba == predictedBayes[[i]]
  cat(mean(q))
  #tab <- table(predicted[[i]],filter(sortedDF, mesec == i+1)$norm_poraba)
  cat(" +/-", sd(q)/sqrt(length(q)), "\n")
}
```

```{r Senzitivnost Naivnega Bayesa}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedBayes[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab["SREDNJA",]), "\n")
}
```



```{r Specifičnost Naivnega Bayesa}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedBayes[[i]])
  cat((sum(tab)-sum(tab["SREDNJA",])-sum(tab[,"SREDNJA"])+tab["SREDNJA","SREDNJA"])/(sum(tab)-sum(tab[,"SREDNJA"])), "\n")
}
```


```{r Preciznost Naivnega Bayesa}
#cat("Preciznost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedBayes[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab[,"SREDNJA"]), "\n")
}
```

```{r Izračun matrike napovedi Naivnega Bayesa}
tic()
tempDF <- list()
predictedMat <- list()
predictedMat <- foreach (i=1:11) %dopar% {
  tempDF[[i]] <- filter(sortedDF, mesec == i+1)
  predictedMat[[i]] <- predict(nb_list[[i]], tempDF[[i]], type = "raw")
}
col.order <- c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")
toc()
head(predictedMat[[1]][,col.order])
```


```{r Barierjev test Naivnega Bayesa}
print("Barier's test", quote = F)
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  bar <- sum((observedMat[[i]] - predictedMat[[i]]) ^ 2) / nrow(predictedMat[[i]])
  cat(bar, "\n")
}
```



```{r Izračun informacijske vsebine Naivnega Bayesa}
cat("Informacijska vsebina odgovora\n")
for (i in 1:11) {
  cat("Mesec =", i+1, " ->  ")
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, predictedMat[[i]]), "\n")
}
```



## K-najbližjih sosedov

```{r Izbira parametra kInNN za K-najbližjih sosedov}
library(CORElearn)
tic("Creating 20 models")
knn_list_kInNN <- list()
tempDF <- filter(sortedDF, mesec <= 1)
drops <- c("poraba")
tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
for(m in 1:20) {
  knn_list_kInNN[[m]] <- CoreModel(norm_poraba ~ ., data = tempDF, model = "knn", kInNN = m)
}
cat("\014")
toc()

tempDF <- filter(sortedDF, mesec == 2)
predictedMatKInKNN <- list()
tic("Predicting on 20 models")
bar <- foreach (i=1:20, .combine=c) %dopar% {
  predictedMatKInKNN[[i]] <- predict(knn_list_kInNN[[i]], tempDF, type = "prob")
  bar <- sum((observedMat[[1]] - predictedMatKInKNN[[i]]) ^ 2) / nrow(predictedMatKInKNN[[i]])
}
toc()
print(bar)
```



```{r Izračun modela K-najbližjih sosedov}
knn_list <- list()
tic("Total")
for(m in 1:11) {
  tempDF <- filter(sortedDF, mesec <= m)
  
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  knn_list[[m]] <- CoreModel(norm_poraba ~ ., data = tempDF, model = "knn", kInNN = 5)
}
cat("\014")
toc()
```


```{r Napoved po modelu K-najbližjih sosedov}
tic("Total")
predictedKNN <- list()
predictedKNN <- foreach (i=1:11) %dopar% {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedKNN[[i]] <- predict(knn_list[[i]], tempDF, type = "class")
}
toc()
```


### Analiza modela K-najbližjih sosedov

```{r Pravilnost rezultatov modela K-najbližjih sosedov}
# Tabela zmot
cat("Pravilnost rezultatov \n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  q <- filter(sortedDF, mesec == i+1)$norm_poraba == predictedKNN[[i]]
  cat(mean(q))
  #tab <- table(predicted[[i]],filter(sortedDF, mesec == i+1)$norm_poraba)
  cat(" +/-", sd(q)/sqrt(length(q)), "\n")
}
```

```{r Senzitivnost modela K-najbližjih sosedov}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedKNN[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab["SREDNJA",]), "\n")
}
```



```{r Specifičnost modela K-najbližjih sosedov}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedKNN[[i]])
  cat((sum(tab)-sum(tab["SREDNJA",])-sum(tab[,"SREDNJA"])+tab["SREDNJA","SREDNJA"])/(sum(tab)-sum(tab[,"SREDNJA"])), "\n")
}
```


```{r Preciznost modela K-najbližjih sosedov}
#cat("Preciznost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedKNN[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab[,"SREDNJA"]), "\n")
}
```



```{r Izračun matrike napovedi modela K-najbližjih sosedov}
tic("Total")
predictedMatKNN <- list()
predictedMatKNN <- foreach (i=1:11) %dopar% {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedMatKNN[[i]] <- predict(knn_list[[i]], tempDF, type = "prob")
}
col.order <- c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")
toc()
head(predictedMatKNN[[1]][,col.order])
```



```{r Barierjev test modela K-najbližjih sosedov}
print("Barier's test", quote = F)
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  bar <- sum((observedMat[[i]] - predictedMatKNN[[i]]) ^ 2) / nrow(predictedMatKNN[[i]])
  cat(bar, "\n")
}
```



```{r Izračun informacijske vsebine modela K-najbližjih sosedov}
cat("Informacijska vsebina odgovora\n")
for (i in 1:11) {
  cat("Mesec =", i+1, " ->  ")
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, predictedMatKNN[[i]]), "\n")
}
```


## Naključni gozd

```{r Izračun Naključnih gozdov}
library(randomForest)
tic("Total")
rm(tempDF)
rf_list <- list()
rf_list <- foreach (m=1:11) %dopar% {
  tempDF <- filter(sortedDF, mesec <= m)
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  rf_list[[m]] <- randomForest(norm_poraba ~ ., data = tempDF)
}
toc()
```


```{r Dopolnilo Naključnih gozdov}
library(randomForest)
tic("Total")

rf_list2 <- list()
rf_list2 <- foreach (m=1) %do% {
  tempDF <- filter(sortedDF, mesec <= m)
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  rf_list2[m] <- randomForest(norm_poraba ~ ., data = tempDF)
}
toc()

rf_list2
```

```{r}
rf_list
```


```{r Napoved po Naključnem gozdu}
tic("Total")
predictedRF <- list()
predictedRF <- foreach (i=1:11) %dopar% {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedRF[[i]] <- predict(rf_list[[i]], tempDF, type = "class")
}
toc()
```


### Analiza Naključnega drevesa

```{r Pravilnost rezultatov Naključnega gozda}
# Tabela zmot
cat("Pravilnost rezultatov \n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  q <- filter(sortedDF, mesec == i+1)$norm_poraba == predictedRF[[i]]
  cat(mean(q))
  #tab <- table(predicted[[i]],filter(sortedDF, mesec == i+1)$norm_poraba)
  cat(" +/-", sd(q)/sqrt(length(q)), "\n")
}
```

```{r Senzitivnost Naključnega gozda}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedRF[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab["SREDNJA",]), "\n")
}
```



```{r Specifičnost Naključnega gozda}
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedRF[[i]])
  cat((sum(tab)-sum(tab["SREDNJA",])-sum(tab[,"SREDNJA"])+tab["SREDNJA","SREDNJA"])/(sum(tab)-sum(tab[,"SREDNJA"])), "\n")
}
```


```{r Preciznost Naključnega gozda}
#cat("Preciznost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predictedRF[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab[,"SREDNJA"]), "\n")
}
```



```{r Izračun matrike napovedi Naključnega gozda}
tic("Total")
predictedMatRF <- list()
predictedMatRF <- foreach (i=1:11) %dopar% {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedMatRF[[i]] <- predict(rf_list[[i]], tempDF, type = "prob")
}
col.order <- c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")
toc()
head(predictedMatRF[[1]][,col.order])
```



```{r Barierjev test Naključnega gozda}
print("Barier's test", quote = F)
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  bar <- sum((observedMat[[i]] - predictedMatRF[[i]]) ^ 2) / nrow(predictedMatRF[[i]])
  cat(bar, "\n")
}
```



```{r Izračun informacijske vsebine Naključnega gozda}
cat("Informacijska vsebina odgovora\n")
for (i in 1:11) {
  cat("Mesec =", i+1, " ->  ")
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, predictedMatRF[[i]]), "\n")
}
```


## Ocena kvalitete artibutov





## Normaliziranje podatkovnega okvirja
```{r Normalizacija zveznih podatkov}
for (i in 1:12) {
  
}
head(sortedDF)
```


## Umetne nevronske mreže


```{r Izračun Nevronske mreže}
library(nnet)
set.seed(0)
nn_list <- list()

for(m in 1:11) {
  tempDF <- filter(sortedDF, mesec <= m)
  
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  nn_list[[m]] <- nnet(norm_poraba ~ ., data = tempDF, size = 5, decay = 0.0001, maxit = 10000)
}

cat("\014")
```

```{r Napoved po Umetni nevronski mreži}
i = 1
predictedKNN <- list()
for (knn in knn_list) {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedKNN[[i]] <- predict(knn, tempDF, type = "class")
  i = i + 1
  cat("Mesec", i, "določen.")
}
```


## Testni chunk

```{r}
rm(predictedMat)
```




#################################################################################
#                                REGRESIJA                                      
#################################################################################

## LINEARNA REGRESIJA    
```{r}
set.seed(0)
sel <- sample(1:nrow(sortedDF), as.integer(nrow(sortedDF) * 0.7), F)
train <- sortedDF[sel,]
test <- sortedDF[-sel,]
model <- lm(poraba ~ ., train)
predicted <- predict(model, test)
observed <- test$poraba
plot(observed)
points(predicted, col="red")

```
Nastavimo seed na 0, da je ob vsakem zagonu enaka naključnost.Vsi podakti se razdelijo na testno in 
učno množico v razmerju 3:7. Model se naredi glede na opazovano spremenljivko "poraba".Graf za te
podatke je prikazan zgoraj.

```{r}
mae <- function(obs, pred)
{
	mean(abs(obs - pred))
}


mse <- function(obs, pred)
{
	mean((obs - pred)^2)
}

mae(observed, predicted)
mse(observed, predicted)
sqrt(mse(observed, predicted))
```
Oznaka "mae" predstavlja srednjo absolutno napako, "mse" pa srednjo kvadratno napako. Če za kvadratno napako
želimo to napako v enakih enotah kot je naša spremenljivka "poraba" moramo "mse" še postaviti pod koren. V izpisu zgoraj zgornja številka predstavlja absolutno napako, spodnji dve pa kvadratno (prva normalno, druga korenjeno).

```{r}
meanVal <- mean(train$poraba)
meanVal

predTrivial <- rep(meanVal, nrow(test))
mae(observed, predTrivial)
mse(observed, predTrivial)
sqrt(mse(observed, predTrivial))

```
Izračunamo povprečno koncentracijo porabe v testni množici(meanVal). Nato izračunamo še srednjo absolutno in
srednjo kvadratno napako za trivialen model, ki ga zgradimo s funkcijo "rep(meanVal, nrow(test)).

Opazimo, da ima naš linearni model manjši obe napaki, kar pomeni, da se je linearni model nekaj naučil in je
boljši od trivialnega modela.


```{r}
rmae <- function(obs, pred, mean.val) 
{  
	sum(abs(obs - pred)) / sum(abs(obs - mean.val))
}

rmse <- function(obs, pred, mean.val) 
{  
	sum((obs - pred)^2)/sum((obs - mean.val)^2)
}


rmae(observed, predicted, mean(train$poraba))
rmse(observed, predicted, mean(train$poraba))

```
S pomočjo relativnih mer ocenimo naš linearni model v primerjavi s trivialnim. Zgornja vrnjena številka prikazuje
relativno srednjo absolutno napako, spodnja pa relativno srednjo kvadratno napako. Ker so vrednosti manjše od 1, to 
pomeni, da je linearni model bojši od trivialnega.


PREČNO PREVERJANJE (LEAVE ONE OUT)

```{r}
predicted <- vector()

for (i in 1:nrow(sortedDF))
{	
	model <- lm(poraba ~ ., sortedDF[-i,])
	predicted[i] <- predict(model, sortedDF[i,])
}

plot(sortedDF$poraba)
points(predicted, col="red")

mae(sortedDF$poraba, predicted)
mse(sortedDF$poraba, predicted)

rmae(sortedDF$poraba, predicted, mean(sortedDF$poraba))
rmse(sortedDF$poraba, predicted, mean(sortedDF$poraba))
```
```{r}
dataTrans <- sortedDF[,c("datum", "regija", "namembnost", "norm_poraba", "vikend", "ura", "stavba", "leto_izgradnje", "temp_zraka", "temp_rosisca", "oblacnost", "padavine", "pritisk", "smer_vetra", "teden", "mesec", "UNIX", "prev_temp", "temp_teden")]
dataTrans$logpovrsina <- log1p(sortedDF$povrsina)
dataTrans$loghitrost_vetra <- log1p(sortedDF$hitrost_vetra)
dataTrans$logporaba <- log1p(sortedDF$poraba)
summary(dataTrans)
```
Atribute se transformira s funkcijo log1p(x), da se izognemo težavam, ki nastanejo, če je ena izmed vrednosti
atributa enaka 0. V izvirni obliki obdržimo kategorične in tiste zvezne atribute, ki imajo približno normalno
porazdelitev, ostale transformiramo.

```{r}
logPredicted <- vector()

for (i in 1:nrow(dataTrans))
{	
	model <- lm(logporaba ~ ., dataTrans[-i,])
	logPredicted[i] <- predict(model, dataTrans[i,])
}
```

Na novih podatkih se izvede prečno preverjanje po principu "leave one out".

```{r}
predicted <- expm1(logPredicted)

plot(sortedDF$poraba)
points(predicted, col="red")

mae(sortedDF$poraba, predicted)
mse(sortedDF$poraba, predicted)

rmae(sortedDF$poraba, predicted, mean(sortedDF$poraba))
rmse(sortedDF$poraba, predicted, mean(sortedDF$poraba))
```

Dobljene napovedi transformiramo v originalni prostor z metodo expm1(x). Izpisane so napake na enak način
kot pri prejšnjih odlomkih kode ("mae", "mse", "rmae", "rmse").















