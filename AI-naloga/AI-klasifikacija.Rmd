---
title: "AI-naloga-unfinished"
output: html_notebook
---

## Obdelava podatkov in dodajanje atributov

Na začetku uvozimo podatke z gumbom v RStudio imenovanem "Import Dataset" in sicer izberemo opcijo "From Text(base)". Nato ustvarimo novo delovno spremenljivko "data", da ostane prvotna spremenljivka nespremenjena. 


```{r}
data <- dataSem1
data$regija <- as.factor(data$regija)
data$namembnost <- as.factor(data$namembnost)
data$norm_poraba <- as.factor(data$norm_poraba)

head(data)
```
Atribute "regija", "namembnost" in "norm_poraba" faktoriziramo, da programski jezik razbere zalogo vrednosti. V tabeli zgoraj je prikazanih prvih nekaj vrstic. 

```{r}
data$datum <- as.Date(data$datum)
head(data)

```
Lastnost atributa "datum" nastavimo na <date>.

```{r}
newData <- week(data$datum)

data$teden <- newData

newNewData <- month(data$datum)
data$mesec <- newNewData

head(data)
```
V tem delu dodamo nova atributa "teden" in "mesec" za lažje nadaljno delo. Za pomoč uporabimo knjižnico "lubridate".

```{r}
x <- is.weekend(data$datum)
data$vikend <- x

#summary(data)
```
Zgornja koda prikazuje kako dodamo atribut "vikend", ki ima vrednost TRUE, če je dan sobota ali nedelja, oziroma FALSE, če je delovni dan. Pomagamo si s knjižnico "chron".


```{r}
data$UNIX <- as.numeric(as.POSIXct(paste(data$datum, data$ura, sep=" ")))
#data
```
Ustvarimo splošen atribut za čas, ki nam omogoča lažje sortiranje.




```{r}
#rm(a)
a <- order(data$stavba, data$ura, data$UNIX)
sortedDF <- data[a,]
#data
sortedDF
```
Dataframe sortiramo po številki stavbe, uri meritve in UNIX času.


```{r}
vect = vector()
starTemp = 0
uraMeritve = 0
for (row in 1:nrow(sortedDF))
{
  if(uraMeritve == sortedDF[row, "ura"]) {
    vect <- c(vect, starTemp)
  }
  else {
    uraMeritve = sortedDF[row, "ura"]
    vect <- c(vect, sortedDF[row, "temp_zraka"])
  }
  starTemp = sortedDF[row, "temp_zraka"]
}

```


```{r}
sortedDF$prev_temp <- vect
head(sortedDF)
```
S kodo zgornjih dveh odlomkov vsaki meritvi v sortirani matriki poiščemo meritev temperature prejšnjega dne in ji le to dopišemo v poseben stolpec z atributi.



```{r}
vect = vector()
starTemp = 0
uraMeritve = 0
substract = 0
beginning = 0
stevec = 0
for (row in 1:nrow(sortedDF))
{
  if(beginning < row-7)
    stevec = row-7
  else
    stevec = beginning
  if(uraMeritve == sortedDF[row, "ura"]) {
    starTemp = 0
    #r <- which(sortedDF[, "stavba"] == sortedDF[row, "stavba"] & sortedDF[, "ura"] == sortedDF[row, "ura"] & sortedDF[, "datum"] == sortedDF[row, "datum"] - substract)
    for (i in stevec:(row-1))
      starTemp = starTemp + sortedDF[i, "temp_zraka"]
    avgTemp = starTemp / (row - stevec)
    vect <- c(vect, avgTemp)
  }
  else {
    beginning = row
    uraMeritve = sortedDF[row, "ura"]
    vect <- c(vect, sortedDF[row, "temp_zraka"])
  }
  starTemp = sortedDF[row, "temp_zraka"]
}

vect
```

```{r}
sortedDF$temp_teden <- vect
```
Z zanko se sprehodimo po vsaki meritvi v matriki in izračunamo povprečje največ zadnjih 7 meritev za isto stavbo ob isti uri. Povprečno temperaturo zapišemo v stolpec z imenom "temp_teden".



## Večinski razred

```{r}
X = factor(sortedDF$norm_poraba, levels=c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA"))
plot(X, main = "Porazdelitev primerov glede na normirano stopnjo porabe")
```
```{r}
summary(X)
```
Večinski parameter je vrednost "SREDNJA", ki predstavlja 76.435 vrednosti od 206.785, kar je 0,3696 od celotne zaloge elementov.


## Odločitveno drevo

```{r}
dt_list <- list()

for(m in 1:11) {
  tempDF <- filter(sortedDF, mesec <= m)
  
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  dt_list[[m]] <- rpart(norm_poraba ~ ., data = tempDF)
}
```
Za izluščenje le posameznega meseca se uporabi knjižnica "dplyr", kjer s pomočjo fukcije "filter" izluščimo le podatke določenega meseca.
Zgoraj so narejena drevesa za vseh 11 mesecev razen decembra, ki se samo testira.


```{r}
for(m in dt_list)
  rpart.plot(m)
```













This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
