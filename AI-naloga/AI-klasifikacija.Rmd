---
title: "AI-naloga-unfinished"
output:
  pdf_document: default
  html_notebook: default
---

## Obdelava podatkov in dodajanje atributov

Na začetku uvozimo podatke z gumbom v RStudio imenovanem "Import Dataset" in sicer izberemo opcijo "From Text(base)". Nato ustvarimo novo delovno spremenljivko "data", da ostane prvotna spremenljivka nespremenjena. 


```{r}
dataSem1 <- read.csv("../../AI-naloga/dataSem1.txt", stringsAsFactors=TRUE)

data <- dataSem1
data$regija <- as.factor(data$regija)
data$namembnost <- as.factor(data$namembnost)
data$norm_poraba <- as.factor(data$norm_poraba)

head(data)
```
Atribute "regija", "namembnost" in "norm_poraba" faktoriziramo, da programski jezik razbere zalogo vrednosti. V tabeli zgoraj je prikazanih prvih nekaj vrstic. 

```{r}
data$datum <- as.Date(data$datum)
head(data)

```
Lastnost atributa "datum" nastavimo na <date>.

```{r}
library(lubridate)

newData <- week(data$datum)

data$teden <- newData

newNewData <- month(data$datum)
data$mesec <- newNewData

head(data)
```
V tem delu dodamo nova atributa "teden" in "mesec" za lažje nadaljno delo. Za pomoč uporabimo knjižnico "lubridate".

```{r}
library(chron)

x <- is.weekend(data$datum)
data$vikend <- x

#summary(data)
```
Zgornja koda prikazuje kako dodamo atribut "vikend", ki ima vrednost TRUE, če je dan sobota ali nedelja, oziroma FALSE, če je delovni dan. Pomagamo si s knjižnico "chron".


```{r}
data$UNIX <- as.numeric(as.POSIXct(paste(data$datum, data$ura, sep=" ")))
#data
```
Ustvarimo splošen atribut za čas, ki nam omogoča lažje sortiranje.




```{r}
#rm(a)
a <- order(data$stavba, data$ura, data$UNIX)
sortedDF <- data[a,]
#data
sortedDF
```
Dataframe sortiramo po številki stavbe, uri meritve in UNIX času.


```{r}
vect = vector()
starTemp = 0
uraMeritve = 0
for (row in 1:nrow(sortedDF))
{
  if(uraMeritve == sortedDF[row, "ura"]) {
    vect <- c(vect, starTemp)
  }
  else {
    uraMeritve = sortedDF[row, "ura"]
    vect <- c(vect, sortedDF[row, "temp_zraka"])
  }
  starTemp = sortedDF[row, "temp_zraka"]
}

```

```{r}
sortedDF$norm_poraba <- factor(sortedDF$norm_poraba, levels=c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA"))

sortedDF$prev_temp <- vect
head(sortedDF)
```
S kodo zgornjih dveh odlomkov vsaki meritvi v sortirani matriki poiščemo meritev temperature prejšnjega dne in ji le to dopišemo v poseben stolpec z atributi.



```{r}
vect = vector()
starTemp = 0
uraMeritve = 0
substract = 0
beginning = 0
stevec = 0
for (row in 1:nrow(sortedDF))
{
  if(beginning < row-7)
    stevec = row-7
  else
    stevec = beginning
  if(uraMeritve == sortedDF[row, "ura"]) {
    starTemp = 0
    #r <- which(sortedDF[, "stavba"] == sortedDF[row, "stavba"] & sortedDF[, "ura"] == sortedDF[row, "ura"] & sortedDF[, "datum"] == sortedDF[row, "datum"] - substract)
    for (i in stevec:(row-1))
      starTemp = starTemp + sortedDF[i, "temp_zraka"]
    avgTemp = starTemp / (row - stevec)
    vect <- c(vect, avgTemp)
  }
  else {
    beginning = row
    uraMeritve = sortedDF[row, "ura"]
    vect <- c(vect, sortedDF[row, "temp_zraka"])
  }
  starTemp = sortedDF[row, "temp_zraka"]
}
```

```{r}
sortedDF$temp_teden <- vect
head(sortedDF)
```
Z zanko se sprehodimo po vsaki meritvi v matriki in izračunamo povprečje največ zadnjih 7 meritev za isto stavbo ob isti uri. Povprečno temperaturo zapišemo v stolpec z imenom "temp_teden".



## Večinski razred

```{r}
plot(sortedDF$norm_poraba, main = "Porazdelitev primerov glede na normirano stopnjo porabe")
```

```{r}
summary(sortedDF$norm_poraba)
```
Večinski parameter je vrednost "SREDNJA", ki predstavlja 76.435 vrednosti od 206.785, kar je 0,3696 od celotne zaloge elementov.


## Odločitveno drevo

```{r}
library(dplyr)
library(rpart)

dt_list <- list()

for(m in 1:11) {
  tempDF <- filter(sortedDF, mesec <= m)
  
  drops <- c("poraba")
  tempDF <- tempDF[ , !(names(tempDF) %in% drops)]
  dt_list[[m]] <- rpart(norm_poraba ~ ., data = tempDF)
}
```
Za izluščenje le posameznega meseca se uporabi knjižnica "dplyr", kjer s pomočjo fukcije "filter" izluščimo le podatke določenega meseca.
Zgoraj so narejena drevesa za vseh 11 mesecev razen decembra, ki se samo testira.


```{r}
library(rpart.plot)

for(m in dt_list)
  rpart.plot(m)
```



```{r}
i = 1
predicted <- list()
for (dt in dt_list) {
  tempDF <- filter(sortedDF, mesec == i+1)
  predicted[[i]] <- predict(dt, tempDF, type = "class")
  i = i + 1
}
```

### Analiza odločitvenega drevesa
```{r}
# Tabela zmot
cat("Pravilnost rezultatov \n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  q <- filter(sortedDF, mesec == i+1)$norm_poraba == predicted[[i]]
  cat(mean(q))
  #tab <- table(predicted[[i]],filter(sortedDF, mesec == i+1)$norm_poraba)
  cat(" +/-", sd(q)/sqrt(length(q)), "\n")
}
```


```{r}
cat("Senzitivnost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predicted[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab["SREDNJA",]), "\n")
}
```



```{r}
cat("Specifičnost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predicted[[i]])
  cat((sum(tab)-sum(tab["SREDNJA",])-sum(tab[,"SREDNJA"])+tab["SREDNJA","SREDNJA"])/(sum(tab)-sum(tab[,"SREDNJA"])), "\n")
}
```


```{r}
cat("Preciznost za 'SREDNJA'\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  tab <- table(filter(sortedDF, mesec == i+1)$norm_poraba, predicted[[i]])
  cat(tab["SREDNJA", "SREDNJA"]/sum(tab[,"SREDNJA"]), "\n")
}
```

```{r}
i = 1
predictedMat <- list()
for (dt in dt_list) {
  tempDF <- filter(sortedDF, mesec == i+1)
  predictedMat[[i]] <- predict(dt, tempDF, type = "prob")
  i = i + 1
}
col.order <- c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")
head(predictedMat[[1]][,col.order])
```

```{r}
library(nnet)

observedMat <- list()
for (i in 1:11) {
  observedMat[[i]] <- class.ind(factor(filter(sortedDF, mesec == i+1)$norm_poraba, levels=c("ZELONIZKA", "NIZKA", "SREDNJA", "VISOKA", "ZELOVISOKA")))
}
head(observedMat[[1]])
```


```{r}
print("Barier's test", quote = F)
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  bar <- sum((observedMat[[i]] - predictedMat[[i]]) ^ 2) / nrow(predictedMat[[i]])
  cat(bar, "\n")
}
```

```{r}
p0 <- table(sortedDF$norm_poraba)/nrow(sortedDF)
cat("Trivialni model\n")
for(i in 1:11){
  cat("Mesec =", i+1, " ->  ")
  p0Mat <- matrix(rep(p0, times=nrow(observedMat[[i]])), nrow = nrow(observedMat[[i]]), byrow = T)
  colnames(p0Mat) <- names(p0)
  bar <- sum((observedMat[[i]] - p0Mat) ^ 2) / nrow(p0Mat)
  cat(bar, "\n")
}

```
> Tale trivialen model je kao boljša metoda kot pa najino drevo. To je treba še enkrat preverit, ker se ne sklada z rezultatom zgoraj. - Najbrž zaradi tega, ker so rezultati v p0Mat povprečje od vseh vrednosti, namesto primerljive učne vrednosti, kot so v posameznih učnih množicah, na katerih potem izdelamo odločitveno drevo

```{r Informacijska vsebina odgovora}
inf.score <- function(trainClass, testClass, predMat) {
  result <- 0
  priors <- table(trainClass) / length(trainClass)
  
  for (i in 1:nrow(predMat)) {
    p.prior <- priors[testClass[i]]
    p.posterior <- predMat[i, testClass[i]]
    
    if(p.posterior >= p.prior) {
      result <- result - log2(p.prior) + log2(p.posterior)
    }
    else
      result <- result + log2(1-p.prior) - log2(1-p.posterior)
  }
  
  result/nrow(predMat)
}
```

```{r}
cat("Informacijska vsebina odgovora\n")
for (i in 1:11) {
  cat("Mesec =", i+1, " ->  ")
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, predictedMat[[i]]), "\n")
}
```

```{r}
cat("Informacijska vsebina trivialnega modela\n")
for (i in 1:11) {
  cat("Mesec =", i+1, " ->  ")
  p0Mat <- matrix(rep(p0, times=nrow(filter(sortedDF, mesec == i+1))), nrow = nrow(filter(sortedDF, mesec == i+1)), byrow = T)
  cat(inf.score(filter(sortedDF, mesec <= i)$norm_poraba, filter(sortedDF, mesec == i+1)$norm_poraba, p0Mat), "\n")
}
```
> Spet podoben problem, kot zgoraj pri trivialnem modelu. Vse vrednosti bi morale biti 0, ampak najbrž niso zaradi napačnega izračuna povprečne porazdelitve v p0 in potem generirani matriki p0Mat











## Testni chunk

```{r}
head(p0Mat)
```




#################################################################################
#                                REGRESIJA                                      #
#################################################################################

LINEARNA REGRESIJA    
```{r}
set.seed(0)
sel <- sample(1:nrow(sortedDF), as.integer(nrow(sortedDF) * 0.7), F)
train <- sortedDF[sel,]
test <- sortedDF[-sel,]
model <- lm(poraba ~ ., train)
predicted <- predict(model, test)
observed <- test$poraba
plot(observed)
points(predicted, col="red")

```
Nastavimo seed na 0, da je ob vsakem zagonu enaka naključnost.Vsi podakti se razdelijo na testno in 
učno množico v razmerju 3:7. Model se naredi glede na opazovano spremenljivko "poraba".Graf za te
podatke je prikazan zgoraj.

```{r}
mae <- function(obs, pred)
{
	mean(abs(obs - pred))
}


mse <- function(obs, pred)
{
	mean((obs - pred)^2)
}

mae(observed, predicted)
mse(observed, predicted)
sqrt(mse(observed, predicted))
```
Oznaka "mae" predstavlja srednjo absolutno napako, "mse" pa srednjo kvadratno napako. Če za kvadratno napako
želimo to napako v enakih enotah kot je naša spremenljivka "poraba" moramo "mse" še postaviti pod koren. V izpisu zgoraj zgornja številka predstavlja absolutno napako, spodnji dve pa kvadratno (prva normalno, druga korenjeno).

```{r}
meanVal <- mean(train$poraba)
meanVal

predTrivial <- rep(meanVal, nrow(test))
mae(observed, predTrivial)
mse(observed, predTrivial)
sqrt(mse(observed, predTrivial))

```
Izračunamo povprečno koncentracijo porabe v testni množici(meanVal). Nato izračunamo še srednjo absolutno in
srednjo kvadratno napako za trivialen model, ki ga zgradimo s funkcijo "rep(meanVal, nrow(test)).

Opazimo, da ima naš linearni model manjši obe napaki, kar pomeni, da se je linearni model nekaj naučil in je
boljši od trivialnega modela.


```{r}
rmae <- function(obs, pred, mean.val) 
{  
	sum(abs(obs - pred)) / sum(abs(obs - mean.val))
}

rmse <- function(obs, pred, mean.val) 
{  
	sum((obs - pred)^2)/sum((obs - mean.val)^2)
}


rmae(observed, predicted, mean(train$poraba))
rmse(observed, predicted, mean(train$poraba))

```
S pomočjo relativnih mer ocenimo naš linearni model v primerjavi s trivialnim. Zgornja vrnjena številka prikazuje
relativno srednjo absolutno napako, spodnja pa relativno srednjo kvadratno napako. Ker so vrednosti manjše od 1, to 
pomeni, da je linearni model bojši od trivialnega.


PRECNO PREVERJANJE (LEAVE ONE OUT)

```{r}
predicted <- vector()

for (i in 1:nrow(sortedDF))
{	
	model <- lm(poraba ~ ., sortedDF[-i,])
	predicted[i] <- predict(model, sortedDF[i,])
}

plot(data$poraba)
points(predicted, col="red")

mae(data$poraba, predicted)
mse(data$poraba, predicted)

rmae(data$poraba, predicted, mean(data$poraba))
rmse(data$poraba, predicted, mean(data$poraba))
```
```{r}
sortedDF
hist(log(sortedDF$padavine))
#log(sortedDF$povrsina)
```

















